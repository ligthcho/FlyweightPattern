享元模式
https://blog.csdn.net/itachi85/article/details/54707942
视频
https://www.bilibili.com/video/av24176315/?p=13

1.解决非抽象的问题 对象带来系统性能上的问题
2.一切皆对象并不现实 int decimal
3.运用共享技术有效地支持大量细粒度的对象
3.共享技术:经常来解决性能手段--整个享元模式的核心思想
4.字符串占用内存比重比较大
5.FlyweightFactory:享元工厂 
 5.1 GetFlyweightFactory(key) 
     基本思想： 
     这个Key在里面做一个判断，如果这个数据结构里面key如果存在的话，直接返回之前的那个对象，
	 如果这个对象没有被创建的话,那么就把这个对象创建出来加进对象池了,然后再返回。
	 创建出来的对象往往是不能更改的，是只读的，否则是不成立的，别人更改的就失去了共享的意义


大家好，我是研发组的小姐姐，今天要讲的主题是设计模式中的享元模式。享元模式跟之前讲的单例模式都是性能模式，解决非抽象的性能问题。
在软件系统中，如果想采用纯对象的方式 有的情况下 大量细粒度的对象很快充斥在系统中 从而带来很高的运行代价
有时候呢 1千几百个对象可能显现不出来，那如果是几万个几十万个这种对象就会带来问题，这个时候怎么办呢，常见的优化手段有共享技术
在很多软件系统里，包含c# c++等，字符串的内存比重是比较大的，常见的系统都对字符串运用了共享技术，虽然实现方式不是今天我们了解的那个，不过思想都是一样的
就是用共享技术有效地支持大量细粒度的对象，线程开销也是很大的，常常我们会用线程池来实现一些共享技术
我们来看看这个类图对享元模式描述定义

本来你创建对象是一个个去new这个对象 本来可以共享你却没有共享
那个如果是用这个工厂的话 这个方法有一个参数叫key 传到里面去做一个判断根据这个Key判断这个对象有没有被创建，
如果已经创建了就返回之前创建的那个对象，如果没有创建的话那就去创建然后返回，
左下角这2块就是说有的对象是支持共享的，有些对象是不支持共享的
我们的看一下实现代码

假设某猫卖商品，如果每个用户下单都生成商品对象显然会耗费很多资源，如果碰上霜11，可怕的订单量会产生很多商品对象，
。。
抽象享元角色是一个商品接口，它定义了showGoodsPrice方法用来展示商品的价格
定义类Goods，它实现IGoods 接口，并实现了showGoodsPrice方法
这个客户端调用的代码
调用GoodsFactory的getGoods方法来创建Goods对象，并调用Goods的showGoodsPrice方法来显示产品的价格。

因为第一次根据iphone7作为Key创建了这个对象，第二次跟第三次调用因为之前已经把这个对象创建出来了，所以直接从缓存中拿就好了

总体的设计思想就是享元的宗旨
这个模式呢在平台上实现的方式有五花八门，但是总体思想 还是解决性能问题 
只有这种模式和单例模式是解决性能上的问题，而不是抽象的问题
还有这种对象往往创建出来就是只读的，否则是不成立的，别人更改的就失去了共享的意义.
好的，我就介绍完了。

